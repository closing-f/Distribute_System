## 分布式事务初探

1. 分布式事务主要有两部分组成。第一个是并发控制（Concurrency Control）第二个是原子提交（Atomic Commit）
2. 数据库通常对于正确性有一个概念称为ACID
   1. Atomic，原子性。要么所有的写数据都完成了，要么没有写数据能完成
   2. Consistent，一致性。我们实际上不会担心这一条，它通常是指数据库会强制某些应用程序定义的数据不变
   3. Isolated，隔离性。这一点还比较重要。这是一个属性，它表明两个同时运行的事务，在事务结束前，能不能看到彼此的更新，能不能看到另一个事务中间的临时的更新。目标是不能。隔离在技术上的具体体现是，事务需要串行执行
   4. Durable，持久化的。在事务提交之后，在数据库中的修改是持久化的，它们不会因为一些错误而被擦除

## 并发控制


1. 乐观并发控制与悲观并发控制
   1. 悲观并发控制：在事务使用任何数据之前，它需要获得数据的锁
   2. 乐观并发控制：通常来说这些执行会在一些临时区域，只有在事务最后的时候，你再检查是不是有一些其他的事务干扰了你。如果没有这样的其他事务，那么你的事务就完成了，并且你也不需要承受锁带来的性能损耗，因为操作锁的代价一般都比较高；但是如果有一些其他的事务在同一时间修改了你关心的数据，并造成了冲突，那么你必须要Abort当前事务，并重试
   3. 如果冲突非常频繁，你或许会想要使用悲观并发控制；如果冲突非常少，那么乐观并发控制可以更快。今天我们只会介绍悲观并发控制
2. 两阶段锁的两个阶段，第一个阶段获取锁，第二个阶段是在事务结束前一直持有锁
3. 有一个计算机会用来管理事务，它被称为事务协调者（Transaction Coordinator），在一个计算机上，事务协调者以某种形式运行事务的代码，例如Put/Get/Add，它向持有了不同数据的其他计算机发送消息，其他计算机再执行事务的不同部分。
4. 每个持有数据的服务器会维护一个锁的表单，用来记录锁被哪个事务所持有。所以对于事务，需要有事务ID（Transaction ID）。我们有事务协调者，我们还有其他的服务器执行部分的事务，这些服务器被称为参与者。
5. **示例：**
   1. 有一个外部的客户端C，它在最最开始的时候会向TC发请求说，请运行这个事务
   2. TC需要确保所有的事务参与者能够完成它们在事务中的那部分工作，会向所有的参与者发送Prepare消息。
   3. 当A或者B收到了Prepare消息，它们就知道事务要执行但是还没执行的内容，它们会查看自身的状态并决定它们实际上能不能完成事务。或许它们需要Abort这个事务因为这个事务会引起死锁，或许它们在故障重启过程中并完全忘记了这个事务因此不能完成事务。它们会向TC回复Yes或者No。

      1. 如果所有的参与者都回复Yes，那么事务可以提交，不会发生错误。之后事务协调者会发出一个Commit消息，给每一个事务的参与者，之后，事务参与者通常会回复ACK说，我们知道了要commit。
      2. 如果任何一个参与者回复了No，那么事务协调者不会发送commit消息，它会发送一轮Abort消息给所有的参与者说，请撤回这个事务。
   4. 在事务Commit之后，事务协调者会向客户端发送代表了事务输出的内容，表明事务结束了，事务没有被Abort并且被持久化保存起来了。事务参与者会释放锁（不论Commit还是Abort都会释放锁）。

## 故障恢复

1. 参与者B可能在回复事务协调者的Prepare消息之前的崩溃了：

   1. 从TC的角度来看，B没有回复Yes，TC也就不能Commit，因为它需要等待所有的参与者回复Yes
   2. B被授权可以单方面的Abort事务。因为B知道自己没有发送Yes，那么它也知道事务协调者不可能Commit事务
   3. 实现方法之一：因为B故障重启了，内存中的数据都会清除，如果事务协调者发送了一个Prepare消息过来，因为B不知道事务，B会回复No，并要求Abort事务。
2. B也可能在回复了Yes给事务协调者的Prepare消息之后崩溃的：

   1. 我们需要确保B在故障恢复之后，仍然能完成事务分包给它的那一部分。
   2. 在B回复Yes给Prepare消息之前，它首先要将相应的Log写入磁盘，并在Log中记录所有有关提交事务必须的信息。这包括了所有由Put创建的新的数值，和锁的完整列表。
   3. 当它重启恢复时，Log里有Commit需要做的所有的修改，和事务持有的所有的锁。之后，当B最终收到了Commit而不是Abort，通过读取Log，B就知道如何完成它在事务中的那部分工作。
3. B可能在收到Commit之后崩溃了：

   1. B完成了修改，并将数据持久化存储在磁盘上了。这样的话，故障重启就不需要做任何事情。
   2. 因为没有收到ACK，事务协调者会再次发送Commit消息：当B重启之后忘记了事务信息：**对于一个它不知道事务的Commit消息，B会简单的ACK这条消息。
4. 如果事务协调者已经向A发送了Commit消息，但是还没来得及向B发送Commit消息就崩溃了

   1. 在发送任何Commit消息之前，它必须先将事务的信息写入到自己的Log，并存放在例如磁盘的持久化存储中，
   2. 恢复软件查看Log可以发现哪些事务执行了一半，哪些事务已经Commit了，哪些事务已经Abort了
5. 事务协调者发送了Prepare消息，但是并没有收到所有的Yes/No消息：

   1. 在事务协调者没有收到Yes/No回复一段时间之后，它可以单方面的Abort事务
   2. 如果一个参与者在这个位置因为等待Prepare消息而超时，那么它也可以决定Abort事务
6. 假设B收到了Prepare消息，并回复了Yes。这个时候参与者没有收到Commit消息：**它必须无限的等待Commit消息，这里通常称为Block。**

在什么时候可以删除Log中有关事务的信息？事务协调者成功的得到了所有参与者的ACK
